
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>水波纹互动（移动 + PC 双端支持）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0a0f1c;
      overflow: hidden;
      touch-action: none;
    }
    .hotspot-wrapper {
      position: absolute;
      width: 0;
      height: 0;
      text-align: center;
    }
    .hotspot {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #ffffff;
      box-shadow: 0 0 8px #ffffff;
      border: 2px solid #ffffff;
      cursor: pointer;
      z-index: 10;
      transform: translate(-50%, -50%);
    }
    .progress-ring {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid #ffffff;
      box-sizing: border-box;
      z-index: 9;
      transform: translate(-50%, -50%);
    }
    .label {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #ffffff;
      font-size: 12px;
      white-space: nowrap;
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }
    .ripple {
      position: absolute;
      border: 2px solid #ffffff;
      border-radius: 50%;
      opacity: 0.5;
      transform: scale(0);
      animation: rippleAnim 0.8s ease-out forwards;
      box-sizing: border-box;
    }
    @keyframes rippleAnim {
      to {
        transform: scale(1);
        opacity: 0;
      }
    }
    .circle {
      position: absolute;
      border-style: solid;
      border-color: #ffffff;
      border-radius: 50%;
      pointer-events: auto;
      box-sizing: border-box;
      cursor: pointer;
    }
    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }
  </style>
</head>
<body>
<svg id="lines"></svg>
<script>
const centerX = window.innerWidth / 2;
const centerY = window.innerHeight / 2;
const svg = document.getElementById('lines');
const allCircles = [];
const maxHoldDuration = 3000;
const endpointRadius = 6;
const labels = [...Array(30)].map((_, i) =>
  ["起点", "分发", "分析", "校验", "同步", "验证", "出口", "入口", "分流", "缓存",
   "确认", "检查", "解码", "转发", "等待", "中继", "核心", "接口", "终端", "回环",
   "感应", "识别", "授权", "提交", "拦截", "记录", "转码", "备份", "统计", "完成"][i] || ("点" + (i + 1))
);

let dragStart = null;
let dragStartTime = null;
let tempLine = null;

function createArcPoints(count, radius, startDeg, endDeg) {
  const points = [];
  const startRad = startDeg * Math.PI / 180;
  const endRad = endDeg * Math.PI / 180;
  for (let i = 0; i < count; i++) {
    const t = i / (count - 1);
    const angle = startRad + (endRad - startRad) * t;
    points.push({
      x: centerX + radius * Math.cos(angle),
      y: centerY + radius * Math.sin(angle)
    });
  }
  return points;
}

function setupHotspot(x, y, labelText) {
  const wrapper = document.createElement('div');
  wrapper.className = 'hotspot-wrapper';
  wrapper.style.left = x + 'px';
  wrapper.style.top = y + 'px';

  const hotspot = document.createElement('div');
  hotspot.className = 'hotspot';
  const ring = document.createElement('div');
  ring.className = 'progress-ring';
  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = labelText;

  wrapper.appendChild(ring);
  wrapper.appendChild(hotspot);
  wrapper.appendChild(label);
  document.body.appendChild(wrapper);

  let holdStartTime = null;
  let holdTimer = null;

  function startHold(e) {
    e.preventDefault();
    holdStartTime = Date.now();
    ring.style.transform = 'translate(-50%, -50%) scale(1)';
    holdTimer = setInterval(() => {
      const ratio = Math.min((Date.now() - holdStartTime) / maxHoldDuration, 1);
      ring.style.transform = `translate(-50%, -50%) scale(${1 + ratio * 1.5})`;
      if (ratio >= 1) clearInterval(holdTimer);
    }, 16);
    dragStart = { x, y };
    dragStartTime = Date.now();
    createTempLine(x, y);
  }

  function endHold() {
    clearInterval(holdTimer);
    if (!holdStartTime) return;
    const duration = Date.now() - holdStartTime;
    const clamped = Math.min(duration, maxHoldDuration);
    const sizeFactor = clamped / maxHoldDuration;
    const distance = 80 + sizeFactor * 220;
    wrapper.remove();
    holdStartTime = null;
    triggerRipple(x, y, distance);
    dragStart = null;
    dragStartTime = null;
  }

  hotspot.addEventListener('touchstart', startHold, { passive: false });
  hotspot.addEventListener('touchend', endHold);
  hotspot.addEventListener('mousedown', startHold);
  document.addEventListener('mouseup', endHold);
}

function triggerRipple(x, y, distance) {
  const count = 3 + Math.floor(distance / 100);
  let prev = 0;
  const radii = [];
  for (let i = 0; i < count; i++) {
    const factor = (count - i) / count;
    const gap = 20 + Math.random() * 10;
    const radius = prev + gap * factor;
    radii.push(radius);
    prev = radius;
  }

  radii.forEach((radius, i) => {
    const ripple = document.createElement('div');
    ripple.className = 'ripple';
    ripple.style.width = ripple.style.height = radius * 2 + 'px';
    ripple.style.left = x - radius + 'px';
    ripple.style.top = y - radius + 'px';
    ripple.style.animationDelay = i * 0.05 + 's';
    document.body.appendChild(ripple);

    setTimeout(() => {
      ripple.remove();
      const circle = document.createElement('div');
      circle.className = 'circle';
      const borderWidth = 2 + Math.random() * 5;
      circle.style.borderWidth = borderWidth + 'px';
      circle.style.width = circle.style.height = radius * 2 + 'px';
      circle.style.left = x - radius + 'px';
      circle.style.top = y - radius + 'px';
      document.body.appendChild(circle);
      addConnectableBehavior(circle, x, y);
    }, 1000 + i * 50);
  });
}

function addConnectableBehavior(dom, x, y) {
  allCircles.push({ dom, x, y });
  dom.addEventListener('mousedown', (e) => {
    e.stopPropagation();
    dragStart = { x, y };
    dragStartTime = Date.now();
    createTempLine(x, y);
  });
  dom.addEventListener('touchstart', (e) => {
    e.stopPropagation();
    dragStart = { x, y };
    dragStartTime = Date.now();
    createTempLine(x, y);
  });
}

function createTempLine(x, y) {
  tempLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
  tempLine.setAttribute("x1", x);
  tempLine.setAttribute("y1", y);
  tempLine.setAttribute("x2", x);
  tempLine.setAttribute("y2", y);
  tempLine.setAttribute("stroke", "#ffffff");
  tempLine.setAttribute("stroke-width", 2);
  svg.appendChild(tempLine);
}

function endLineDraw(x, y, duration) {
  const width = 2 + Math.min(duration, 2000) / 2000 * 8;
  const target = allCircles.find(c => {
    const dx = x - c.x;
    const dy = y - c.y;
    return Math.hypot(dx, dy) < 25 && (c.x !== dragStart.x || c.y !== dragStart.y);
  });

  if (target) {
    const dx = target.x - dragStart.x;
    const dy = target.y - dragStart.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const unitX = dx / dist;
    const unitY = dy / dist;
    const sx = dragStart.x + unitX * endpointRadius;
    const sy = dragStart.y + unitY * endpointRadius;
    const ex = target.x - unitX * endpointRadius;
    const ey = target.y - unitY * endpointRadius;

    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", sx);
    line.setAttribute("y1", sy);
    line.setAttribute("x2", ex);
    line.setAttribute("y2", ey);
    line.setAttribute("stroke", "#ffffff");
    line.setAttribute("stroke-width", width);
    svg.appendChild(line);

    [dragStart, target].forEach(pos => {
      const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      c.setAttribute("cx", pos.x);
      c.setAttribute("cy", pos.y);
      c.setAttribute("r", endpointRadius);
      c.setAttribute("fill", "none");
      c.setAttribute("stroke", "#ffffff");
      c.setAttribute("stroke-width", 2);
      svg.appendChild(c);
    });
  }

  if (tempLine) tempLine.remove();
  tempLine = null;
  dragStart = null;
  dragStartTime = null;
}

document.addEventListener('touchmove', (e) => {
  if (dragStart && tempLine) {
    const touch = e.touches[0];
    tempLine.setAttribute('x2', touch.clientX);
    tempLine.setAttribute('y2', touch.clientY);
  }
});
document.addEventListener('touchend', (e) => {
  if (!dragStart || !dragStartTime) return;
  const touch = e.changedTouches[0];
  endLineDraw(touch.clientX, touch.clientY, Date.now() - dragStartTime);
});
document.addEventListener('mousemove', (e) => {
  if (dragStart && tempLine) {
    tempLine.setAttribute('x2', e.clientX);
    tempLine.setAttribute('y2', e.clientY);
  }
});
document.addEventListener('mouseup', (e) => {
  if (!dragStart || !dragStartTime) return;
  endLineDraw(e.clientX, e.clientY, Date.now() - dragStartTime);
});

// 初始化圆圈和标签
createArcPoints(20, 200, 0, 342).forEach(({x, y}, i) => setupHotspot(x, y, labels[i] || '点' + i));
createArcPoints(10, 400, 0, 324).forEach(({x, y}, i) => setupHotspot(x, y, labels[i+20] || '点' + (i+20)));
</script>
</body>
</html>
